# New version React

---

## Install

Using **[npx create-react-app my-app]**, install create-react-app
Using **[npm start]** to run the code.

## Edit

1. index.js: The index.js file is the entry point to your React application. It primarily serves the following purposes.

```
1.1 Calling ReactDOM.render(): Renders React elements to the real DOM via the React DOM library's ReactDOM.render() function.

1.2 Render the <App /> component (a feature of App.js discussed below) inside a DOM element with an id of 'root' in index.html

1.3 Typically, this file imports the necessary components and libraries, and performs initialization tasks.
```

2. App.js: The App.js file is primarily used as the root component of an application

```
2.1 Define and export React components. They are typically written as class or functional components.

2.2 It primarily combines and organizes other components to create the layout and structure of the overall app. Within this file, other components are called and combined to create the UI.

2.3 Used in conjunction with React Router or another state management library, it can be responsible for things like routing configuration or state management for your app.
```

- Index.js is the entry point for rendering and launching your app, while App.js is responsible for defining and organizing the main components of your application. Both play an important role in a React application, and work together to make up the entire app.

## Deployment

An application run with **[npm start]** is a development application. It is good for development, but it is not suitable for use in a real service because it is large and contains such as unnecessary messages.

If so, can you create an efficient application for your service?

In the terminal, type **[npm run build]** to start the build command.

The **[npm run build]** command is typically used before deploying a React application. When you run it, it creates a set of static files that are optimized for the production environment.

**Key features:**

- Generate optimized builds: optimize and bundle source code to reduce size and improve performance. This is done by minimizing CSS, JavaScript, and image files and generating them in the build directory.

- Static file generation: During development with tools like **create-react-app**, there may be unused files or code. **[npm run build]** removes these unnecessary pieces and bundles the necessary files together.

- Apply environment settings: There are settings required for production that are different from development. For example, Source Maps are usually disabled in production builds.

- Generate deliverables: When the build is complete, a series of static files are generated. These files can be deployed to a web server to host your application, or uploaded to a CDN to make them accessible to users.

The output generated by the **[npm run build]** command is usually stored in the _build_ or _dist_ directory, which makes your app available for deployment. These built files are not the source code, but rather the version that will be delivered to end users, which is smaller in size and optimized for better performance.

**[npx serve -s build]**

The **[npx serve -s build]** command runs a simple local web server that serves the production-built files of your project. This allows you to test the production build of the application you're developing locally. After building that project, running this command will allow you to preview the application locally.

---

# Component

```
React is a technology for creating custom tags.
```

Do you agree with that?

In a way, yes, but the statement might need a bit of clarification. React is a JavaScript library primarily used for building user interfaces, specifically for web applications. It allows developers to create reusable UI components, which can indeed be thought of as custom tags in a sense.

These components can encapsulate various functionalities and represent specific parts of the UI. When you use React, you essentially create your own custom HTML elements or tags by defining these components. For example, you might create a Header, Button, or Card component, and then use them in your code as if they were HTML tags.

So, while React itself doesn't directly create HTML tags, it provides a way to build custom components that can be used similarly to HTML tags within your application, thereby allowing you to create your own reusable, custom elements to structure your UI.

**Simple webpage code for example**

```JavaScript
<div className="App">
    <header className="App-header">
        <h1>
            <a href="/">WEB</a>
        </h1>
    </header>
    <nav>
        <ol>
            <li>
                <a href="/read/1">HTML</a>
            </li>
            <li>
                <a href="/read/2">CSS</a>
            </li>
            <li>
                <a href="/read31">JavaScript</a>
            </li>
        </ol>
    </nav>
    <article>
        <h2>Welcom</h2>
        Hello, WEB
    </article>
</div>
```

This code has some HTML tags for organizing web pages. As you can see, it is not too long because it is simple code for example. By the wat, what if there are thousond of code lines for complicate web page? what about we need more pages? If so, the code will become more complex and unreadable.

_What do we need to do?_

> Create a custom tag, also known as **component**.

In React, a component is a fundamental building block used to create user interfaces. Components are reusable and self-contained pieces of code that encapsulate a part of the UI's functionality and appearance.

1. Functional Components: These are JavaScript functions that accept properties (props) as arguments and return React elements that describe the UI. They are typically used for simpler components.

2. Class Components: These are ES6 classes that extend the React.Component class. They include a render() method that returns the UI description. Class components have additional features like local state and lifecycle methods.

Components allow developers to create a modular and reusable UI. They can be composed together to form more complex UI structures. Each component can manage its own state (in the case of class components) or receive data through props to render UI based on that data.

```JavaScript
function Header() {
	return (
		<header className="App-header">
			<h1>
				<a href="/">WEB</a>
			</h1>
		</header>
	);
}
    ...

function App() {
	return (
			<Header></Header>
    ...
```

---

# props

[example code]

```javascript
<Header></Header>
<Nav></Nav>

<img src="image.jpg" width="100" height="100">
```

Image tags can have input values thanks to "attributes" like src, width, and height.
But what if components also have properties?

- What is a prop in React?
  -> In React, "props" represent properties (data) that are passed from the parent component. They are used to pass data from the parent component to the child component. These data are read-only in the child component and cannot be changed.

- Using props to pass data between components allows you to reuse components and create flexible structures.

```javascript
function Article(props) {
	return (
		<article>
			<h2>{props.title}</h2>
			{props.body}
		</article>
	);
}
function App() {
	return (
		<div className="App">
			...
			<Article title="Welcom" body="Hello,Web"></Article>
		</div>
	);
}
```

- Create a separate array called topics and send it to the props and receive it, creating a list of them one by one.

```javascript
function App() {
	const topics = [
		{ id: 1, title: "html", body: "html is ..." },
		{ id: 2, title: "CSS", body: "CSS is ..." },
		{ id: 3, title: "JavaScript", body: "JavaScript is ..." },
	];
	return (
		<div className="App">
			...
			<Nav topics={topics}></Nav>
			...
		</div>
	);
}
```

```javascript
function Nav(props) {
	const lis = [];
	for (let i = 0; i < props.topics.length; i++) {
		let t = props.topics[i];
		lis.push(
			<li key={t.id}>
				<a href={"/read" + t.id}>{t.title}</a>
			</li>
		);
	}
	return (
		<nav>
			<ol>{lis}</ol>
		</nav>
	);
}
```

- used a props to output different results depending on the value we send.

---

# event

[example code]

```JavaScript
<input type="button" onclick="alert('hi')">
```

The **onclick** function allows the user to get a warning when a button is clicked.

What if 'component' has these function that allows the user to get more works?
-> **event**

[example 1]

1. Implemented new function functionality in the <Header> component.

```JavaScript
<Header
    title="WEB"
    onChangeMode={()=> {
        alert("Header");
    }}
></Header>
```

2. <Header> component when an event called 'click' occurs,

1) prohibit the page from reloading, and
2) call the function pointed to by 'onChangeMode' passed as a prop
   passed as a prop.

```JavaScript
function Header(props) {
	return (
		<header className="App-header">
			<h1>
				<a
					href="/"
					onClick={(event) => {
						event.preventDefault(); //prevent reload
						props.onChangeMode();
					}}
				>
					{props.title}
				</a>
			</h1>
		</header>
	);
}
```

[example 2]

- Want to display the corresponding id value in an alert when the content inside the <Nav> is clicked.

1. Implement the function you want to implement inside the <Nav> that "fires an alert with the id value".

```JavaScript
<Nav
    topics={topics}
    onChangeMode={(id) => {
        alert(id);
    }}
></Nav>
```

2. When the 'click' event is fired on the <Nav> component,

1) prohibit the page from reloading, and
2) sends the id value of the clicked list to the onChangeMode passed to the props in the
   function that sends the id of the clicked list to the onChangeMode passed to the proxy.

- How do I get the id attribute of an <a> tag inside an Event function?
  -> Use the event object, and get the id value of the event object's target (the tag that triggered the event === <a>).

```JavaScript
function Nav(props) {
	const lis = [];
	for (let i = 0; i < props.topics.length; i++) {
		let t = props.topics[i];
		lis.push(
			<li key={t.id}>
				<a
					id={t.id}
					href={"/read" + t.id}
					onClick={(event) => {
						event.preventDefault();
						props.onChangeMode(event.target.id);
					}}
				>
					{t.title}
				</a>
			</li>
		);
	}
	return (
		<nav>
			<ol>{lis}</ol>
		</nav>
	);
}
```

---

# state

In React, state is a JavaScript object that is used to store and manage component-specific data. It represents the dynamic aspects of a component that can change over time. State allows React components to keep track of changes and update the user interface accordingly.

![Alt text](<IMG_A8E51F9C1B30-1 copy.jpeg>)

React components have inputs and outputs. The input is the **props**, and the output is the **return**, which is the result of running a function on the props. This return value is the new UI.

There is one other piece of data in the process, which is the **state**.
Both the props and the state will output a new UI when their values change.

Difference between props and states:
Props are data for outsiders using the component that is stored in the
State is data for the insiders who create the component.

[practice1]
-> Make it so that clicking on the Header displays the welcome page, and clicking on the topics in the Nav displays read page.

```JavaScript
import { useState } from "react";

const [mode, setMode] = useState("WELCOME");

if (mode === "WELCOME") {
		content = <Article title="Welcome" body="Hello, Web"></Article>;
	} else if (mode === "READ") {
		content = <Article title="Read" body="Hello, Read"></Article>;
	}

return(
...
{content}{" "}
...
)
```

[practice2]
-> clicking on the topics in the Nav displays their respective contents.

```JavaScript
const [id, setId] = useState(null);

function Nav(props) {
    ...
    <a
        id={t.id}
        href={"/read" + t.id}
        onClick={(event) => {
            event.preventDefault();
            props.onChangeMode(Number(event.target.id));
        }}
    >
        {t.title}
    </a>
    ...
}

else if (mode === "READ") {
    let title,
        body = null;
    for (let i = 0; i < topics.length; i++) {
        if (topics[i].id === id) {
            title = topics[i].title;
            body = topics[i].body;
        }
    }
    content = <Article title={title} body={body}></Article>;
}

return(
    <Nav
        topics={topics}
        onChangeMode={(_id) => {
            setMode("READ");
            setId(_id);
        }}
    ></Nav>
)

```

---

[Create/Read/Update/Delete]

# Create

- Create a Create button and implement a form that allows you to add a new item when the button is clicked.
  Add the contents of the title and description of the new item to create it, and implement the display of the contents on the screen.

```JavaScript
function Create(props) {
	return (
		<article>
			<h2>Create</h2>
			<form
				onSubmit={(event) => {
					event.preventDefault();
					const title = event.target.title.value;
					const body = event.target.body.value;
					props.onCreate(title, body);
				}}
			>
				<p>
					<input type="text" name="title" placeholder="title"></input>
				</p>
				<p>
					<textarea name="body" placeholder="description"></textarea>
				</p>
				<p>
					<input type="submit" value="Create"></input>
				</p>
			</form>
		</article>
	);
}

function App(){
	...
const [nextId, setNextId] = useState();
const [topics, setTopics] = useState([
	{ id: 1, title: "html", body: "html is ..." },
	{ id: 2, title: "CSS", body: "CSS is ..." },
	{ id: 3, title: "JavaScript", body: "JavaScript is ..." },
]);
...
else if (mode === "CREATE") {
	content = (
		<Create
			onCreate={(_title, _body) => {
				const newTopic = { id: nextId, title: _title, body: _body };
				const newTopics = [...topics]; //make a copy of origin
				newTopics.push(newTopic); //add new to copy of origin
				setTopics(newTopics); //set copy as a new one
			}}
		></Create>
	);
}

return(
	...
	<a
		href="/create"
		onClick={(event) => {
			event.preventDefault();
			setMode("CREATE");
		}}
	>
		Create
	</a>
	...
)
}
```

- const [value, setValue] = useState(PRIMITIVE);
  [string, number, binint,boolean, undefined, symbol, null]
  -> setValue(newValue)

- const [valu, setValue] = useState(Object);
  [object, array]
  -> newValue = {...value} // create copy of origin
  -> add or edit newValue
  -> setValue(newValue) // setValue with copied value

[ex]
const[value, setValue] = useState(1);
setValue(2);
-> no problem

const[value, setValue] = useState([1]);
value.push(2);
setValue(value);
-> **problem**
The first value and the next value are recognized as the same value, so no change is made.

newValue = [...value];
newValue.push(2);
setValue(newValue);
-> no problem

- After creating, display the content and set the username and next username.

```JavaScript
else if (mode === "CREATE") {
	content = (
		<Create
		...
				setMode("READ");
				setId(nextId);
				setNextId(nextId + 1);
			}}
		></Create>
	);
}
```

---

# Update

Update = Create + Read

- The Update function should modify the existing content and replace it with new information.
  It should also only be implemented when viewing an existing topic entry, so it should not appear on the welcome page.

When in 'READ' mode, create a button to implement the Update functionality and configure the <Update> component.

The Update function is similar to Create.
It loads the existing content, takes the user's input, modifies the content, and registers the modified content as new.

```JavaScript
function Update(props) {
	const [title, setTitle] = useState(props.title);
	const [body, setBody] = useState(props.body);
	return (
		<article>
			<h2>Update</h2>
			<form
				onSubmit={(event) => {
					event.preventDefault();
					const title = event.target.title.value;
					const body = event.target.body.value;
					props.onUpdate(title, body);
				}}
			>
				<p>
					<input
						type="text"
						name="title"
						placeholder="title"
						value={title}
						onChange={(event) => {
							setTitle(event.target.value);
						}}
					></input>
				</p>
				<p>
					<textarea
						name="body"
						placeholder="description"
						value={body}
						onChange={(event) => {
							setBody(event.target.value);
						}}
					></textarea>
				</p>
				<p>
					<input type="submit" value="Update"></input>
				</p>
			</form>
		</article>
	);
}

function App(){
	...
	let contextControl = null;
	...
	else if (mode === "UPDATE") {
		let title,
			body = null;
		for (let i = 0; i < topics.length; i++) {
			if (topics[i].id === id) {
				title = topics[i].title;
				body = topics[i].body;
			}
		}
		content = (
			<Update
				title={title}
				body={body}
				onUpdate={(_title, _body) => {
					const updatedTopic = { id: id, title: _title, body: _body };
					const newTopics = [...topics];
					for (let i = 0; i < newTopics.length; i++) {
						if (newTopics[i].id === id) {
							newTopics[i] = updatedTopic;
							break;
						}
					}
					setTopics(newTopics);
					setMode("READ");
				}}
			></Update>
		);
	}

	return(
		<ul>
			...
			{contextControl}
		</ul>
	)

}
```

Inside the App function, in the else if(mode === "UPDATE") section, we need to get the title and body values of the clicked topic and send them to the <Update> component, which indicates the content of the received values, and receives the user's input to change the content.

---

# Delete

Delete can be implemented using a button because it deletes the content of a link without moving it.

When the button is clicked, topics that do not have the same ID value as the topic in question are put into an empty array and deleted by setting the new array as the state value.

```JavaScript
function App(){
	...
	else if (mode === "READ") {
...
contextControl = (
	<>
		<li>
			<input
				type="button"
				value="Delete"
				onClick={() => {
					const newTopics = [];
					for (let i = 0; i < topics.length; i++) {
						if (topics[i].id !== id) {
							newTopics.push(topics[i]);
						}
					}
					setTopics(newTopics);
					setMode("WELCOME");
				}}
			/>
		</li>
	</>
	);
}}
```
